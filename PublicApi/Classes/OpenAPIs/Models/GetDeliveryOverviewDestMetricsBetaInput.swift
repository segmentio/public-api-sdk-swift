//
// GetDeliveryOverviewDestMetricsBetaInput.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

/** Input of the Delivery Overview Destination steps. */
public struct GetDeliveryOverviewDestMetricsBetaInput: Codable, JSONEncodable, Hashable {

    public enum Granularity: String, Codable, CaseIterable {
        case day = "day"
        case hour = "hour"
        case minute = "minute"
    }
    /** The sourceId for the Workspace. */
    public var sourceId: String
    /** The id tied to a Workspace Destination. */
    public var destinationConfigId: String
    /** The ISO8601 formatted timestamp corresponding to the beginning of the requested timeframe, inclusive. */
    public var startTime: String
    /** The ISO8601 formatted timestamp corresponding to the end of the requested timeframe, noninclusive. */
    public var endTime: String
    /** A comma-delimited list of strings representing one or more dimensions to group the result by.  Valid options are: `eventName`, `eventType`, `discardReason`, and `appVersion`. */
    public var groupBy: [String]?
    /** The size of each bucket in the requested window.  Based on the granularity chosen, there are restrictions on the time range you can query:  **Minute**: - Max time range: 4 hours - Oldest possible start time: 48 hours in the past  **Hour**: - Max Time range: 14 days - Oldest possible start time: 30 days in the past  **Day**: - Max time range: 30 days - Oldest possible start time: 30 days in the past */
    public var granularity: Granularity
    public var filter: Filter?
    public var pagination: Pagination2
    /** An optional filter for actions destinations, to filter by a specific action. */
    public var subscriptionId: String?

    public init(sourceId: String, destinationConfigId: String, startTime: String, endTime: String, groupBy: [String]? = nil, granularity: Granularity, filter: Filter? = nil, pagination: Pagination2, subscriptionId: String? = nil) {
        self.sourceId = sourceId
        self.destinationConfigId = destinationConfigId
        self.startTime = startTime
        self.endTime = endTime
        self.groupBy = groupBy
        self.granularity = granularity
        self.filter = filter
        self.pagination = pagination
        self.subscriptionId = subscriptionId
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case sourceId
        case destinationConfigId
        case startTime
        case endTime
        case groupBy
        case granularity
        case filter
        case pagination
        case subscriptionId
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(sourceId, forKey: .sourceId)
        try container.encode(destinationConfigId, forKey: .destinationConfigId)
        try container.encode(startTime, forKey: .startTime)
        try container.encode(endTime, forKey: .endTime)
        try container.encodeIfPresent(groupBy, forKey: .groupBy)
        try container.encode(granularity, forKey: .granularity)
        try container.encodeIfPresent(filter, forKey: .filter)
        try container.encode(pagination, forKey: .pagination)
        try container.encodeIfPresent(subscriptionId, forKey: .subscriptionId)
    }
}

