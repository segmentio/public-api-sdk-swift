//
// AudienceSummaryWithAudienceTypeAndLookback.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

public struct AudienceSummaryWithAudienceTypeAndLookback: Codable, JSONEncodable, Hashable {

    public enum AudienceType: String, Codable, CaseIterable {
        case accounts = "ACCOUNTS"
        case linked = "LINKED"
        case users = "USERS"
    }
    /** Discriminator denoting the audience's product type. */
    public var audienceType: AudienceType
    public var computeCadence: ComputeCadence
    public var size: Size1?
    public var options: Options6?
    /** Audience id. */
    public var id: String
    /** Space id for the audience. */
    public var spaceId: String
    /** Name of the audience. */
    public var name: String
    /** Description of the audience. */
    public var description: String?
    /** Key for the audience. */
    public var key: String
    /** Enabled/disabled status for the audience. */
    public var enabled: Bool
    public var definition: Definition7?
    /** Status for the audience.  Possible values: Backfilling, Computing, Failed, Live, Awaiting Destinations, Disabled. */
    public var status: String?
    /** User id who created the audience. */
    public var createdBy: String
    /** User id who last updated the audience. */
    public var updatedBy: String
    /** Date the audience was created. */
    public var createdAt: String
    /** Date the audience was last updated. */
    public var updatedAt: String

    public init(audienceType: AudienceType, computeCadence: ComputeCadence, size: Size1? = nil, options: Options6? = nil, id: String, spaceId: String, name: String, description: String? = nil, key: String, enabled: Bool, definition: Definition7?, status: String? = nil, createdBy: String, updatedBy: String, createdAt: String, updatedAt: String) {
        self.audienceType = audienceType
        self.computeCadence = computeCadence
        self.size = size
        self.options = options
        self.id = id
        self.spaceId = spaceId
        self.name = name
        self.description = description
        self.key = key
        self.enabled = enabled
        self.definition = definition
        self.status = status
        self.createdBy = createdBy
        self.updatedBy = updatedBy
        self.createdAt = createdAt
        self.updatedAt = updatedAt
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case audienceType
        case computeCadence
        case size
        case options
        case id
        case spaceId
        case name
        case description
        case key
        case enabled
        case definition
        case status
        case createdBy
        case updatedBy
        case createdAt
        case updatedAt
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(audienceType, forKey: .audienceType)
        try container.encode(computeCadence, forKey: .computeCadence)
        try container.encodeIfPresent(size, forKey: .size)
        try container.encodeIfPresent(options, forKey: .options)
        try container.encode(id, forKey: .id)
        try container.encode(spaceId, forKey: .spaceId)
        try container.encode(name, forKey: .name)
        try container.encodeIfPresent(description, forKey: .description)
        try container.encode(key, forKey: .key)
        try container.encode(enabled, forKey: .enabled)
        try container.encode(definition, forKey: .definition)
        try container.encodeIfPresent(status, forKey: .status)
        try container.encode(createdBy, forKey: .createdBy)
        try container.encode(updatedBy, forKey: .updatedBy)
        try container.encode(createdAt, forKey: .createdAt)
        try container.encode(updatedAt, forKey: .updatedAt)
    }
}

